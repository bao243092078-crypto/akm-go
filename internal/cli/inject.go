package cli

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/baobao/akm-go/internal/core"
	"github.com/spf13/cobra"
)

var injectCmd = &cobra.Command{
	Use:   "inject",
	Short: "生成 .env 文件",
	Long: `在当前目录生成 .env 文件，包含所有或指定的密钥。

示例:
  akm inject                    # 生成包含所有密钥的 .env
  akm inject -p openai          # 只包含 OpenAI 的密钥
  akm inject -k KEY1,KEY2       # 只包含指定的密钥
  akm inject -o custom.env      # 输出到指定文件
  akm inject --project          # 根据 akm.yaml 精确注入
  akm inject --all ~/projects   # 扫描目录，批量注入所有有 akm.yaml 的项目`,
	RunE: func(cmd *cobra.Command, args []string) error {
		provider, _ := cmd.Flags().GetString("provider")
		keyNames, _ := cmd.Flags().GetString("keys")
		output, _ := cmd.Flags().GetString("output")
		force, _ := cmd.Flags().GetBool("force")
		useProject, _ := cmd.Flags().GetBool("project")
		allDir, _ := cmd.Flags().GetString("all")

		storage, err := core.GetStorage()
		if err != nil {
			return fmt.Errorf("failed to initialize storage: %w", err)
		}

		// --all mode: scan parent directory for akm.yaml files
		if allDir != "" {
			// Expand ~ to home directory
			if strings.HasPrefix(allDir, "~/") {
				homeDir, _ := os.UserHomeDir()
				allDir = filepath.Join(homeDir, allDir[2:])
			}
			return injectAll(storage, allDir, force)
		}

		cwd, _ := os.Getwd()

		// --project mode: use akm.yaml
		if useProject {
			return injectFromConfig(storage, cwd, force)
		}

		// Default mode: inject all or filtered keys
		if output == "" {
			output = ".env"
		}

		if !force {
			if _, err := os.Stat(output); err == nil {
				return fmt.Errorf("文件 '%s' 已存在，使用 -f 强制覆盖", output)
			}
		}

		var names []string
		if keyNames != "" {
			names = strings.Split(keyNames, ",")
			for i, name := range names {
				names[i] = strings.TrimSpace(name)
			}
		}

		project := filepath.Base(cwd)
		keys, err := storage.GetKeysForInjection(project, provider, names)
		if err != nil {
			return fmt.Errorf("获取密钥失败: %w", err)
		}

		if len(keys) == 0 {
			printWarning("没有找到匹配的密钥")
			return nil
		}

		content := buildEnvContent(project, keys)
		if err := os.WriteFile(output, []byte(content), 0600); err != nil {
			return fmt.Errorf("写入文件失败: %w", err)
		}

		printSuccess("已生成 %s (%d 个密钥)", output, len(keys))
		return nil
	},
}

func injectFromConfig(storage *core.KeyStorage, dir string, force bool) error {
	config, err := core.LoadProjectConfig(dir)
	if err != nil {
		return err
	}

	project := filepath.Base(dir)
	keys, err := storage.GetKeysForInjection(project, config.Provider, config.Keys)
	if err != nil {
		return fmt.Errorf("获取密钥失败: %w", err)
	}

	if len(keys) == 0 {
		printWarning("akm.yaml 中声明的密钥均未找到")
		return nil
	}

	// Warn about missing keys
	for _, name := range config.Keys {
		if _, ok := keys[name]; !ok {
			printWarning("密钥 '%s' 在 akm.yaml 中声明但未找到", name)
		}
	}

	output := filepath.Join(dir, ".env")
	if !force {
		if _, err := os.Stat(output); err == nil {
			return fmt.Errorf("文件 '%s' 已存在，使用 -f 强制覆盖", output)
		}
	}

	content := buildEnvContent(project, keys)
	if err := os.WriteFile(output, []byte(content), 0600); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	printSuccess("[%s] 已生成 .env (%d/%d 个密钥)", project, len(keys), len(config.Keys))
	return nil
}

func injectAll(storage *core.KeyStorage, parentDir string, force bool) error {
	configs, err := core.FindProjectConfigs(parentDir)
	if err != nil {
		return fmt.Errorf("扫描目录失败: %w", err)
	}

	if len(configs) == 0 {
		printWarning("在 %s 下未找到任何 akm.yaml", parentDir)
		return nil
	}

	fmt.Printf("找到 %d 个项目配置\n\n", len(configs))

	var success, failed int
	for dir := range configs {
		if err := injectFromConfig(storage, dir, force); err != nil {
			printError("[%s] %v", filepath.Base(dir), err)
			failed++
		} else {
			success++
		}
	}

	fmt.Printf("\n完成: %d 成功, %d 失败\n", success, failed)
	if failed > 0 {
		return fmt.Errorf("%d 个项目注入失败", failed)
	}
	return nil
}

func buildEnvContent(project string, keys map[string]string) string {
	var lines []string
	lines = append(lines, "# Generated by akm (API Key Manager)")
	lines = append(lines, fmt.Sprintf("# Project: %s", project))
	lines = append(lines, "")

	for name, value := range keys {
		escapedValue := core.EscapeDotenvValue(value)
		lines = append(lines, fmt.Sprintf("%s=\"%s\"", name, escapedValue))
	}

	return strings.Join(lines, "\n") + "\n"
}

var runCmd = &cobra.Command{
	Use:   "run -- <command>",
	Short: "注入环境变量运行命令",
	Long: `将密钥作为环境变量注入，然后运行指定的命令。

示例:
  akm run -- python app.py
  akm run -p openai -- node server.js
  akm run -k OPENAI_API_KEY,ANTHROPIC_API_KEY -- ./script.sh`,
	Args:                  cobra.MinimumNArgs(1),
	DisableFlagParsing:    false,
	DisableFlagsInUseLine: true,
	RunE: func(cmd *cobra.Command, args []string) error {
		provider, _ := cmd.Flags().GetString("provider")
		keyNames, _ := cmd.Flags().GetString("keys")

		storage, err := core.GetStorage()
		if err != nil {
			return fmt.Errorf("failed to initialize storage: %w", err)
		}

		// Get keys
		var names []string
		if keyNames != "" {
			names = strings.Split(keyNames, ",")
			for i, name := range names {
				names[i] = strings.TrimSpace(name)
			}
		}

		cwd, _ := os.Getwd()
		project := filepath.Base(cwd)

		keys, err := storage.GetKeysForInjection(project, provider, names)
		if err != nil {
			return fmt.Errorf("获取密钥失败: %w", err)
		}

		// Build environment
		env := os.Environ()
		for name, value := range keys {
			env = append(env, fmt.Sprintf("%s=%s", name, value))
		}

		// Run command
		cmdName := args[0]
		cmdArgs := args[1:]

		execCmd := exec.Command(cmdName, cmdArgs...)
		execCmd.Env = env
		execCmd.Stdin = os.Stdin
		execCmd.Stdout = os.Stdout
		execCmd.Stderr = os.Stderr

		return execCmd.Run()
	},
}

var exportCmd = &cobra.Command{
	Use:   "export",
	Short: "导出密钥为 shell 格式",
	Long: `导出密钥为 shell export 格式，可用于 eval。

示例:
  eval "$(akm export)"              # 导出到当前 shell
  akm export -p openai              # 只导出 OpenAI 密钥
  akm export --format json          # JSON 格式输出`,
	RunE: func(cmd *cobra.Command, args []string) error {
		provider, _ := cmd.Flags().GetString("provider")
		keyNames, _ := cmd.Flags().GetString("keys")
		format, _ := cmd.Flags().GetString("format")

		storage, err := core.GetStorage()
		if err != nil {
			return fmt.Errorf("failed to initialize storage: %w", err)
		}

		// Get keys
		var names []string
		if keyNames != "" {
			names = strings.Split(keyNames, ",")
			for i, name := range names {
				names[i] = strings.TrimSpace(name)
			}
		}

		keys, err := storage.GetKeysForExport("cli-export", provider, names)
		if err != nil {
			return fmt.Errorf("获取密钥失败: %w", err)
		}

		switch format {
		case "json":
			fmt.Println("{")
			i := 0
			for name, value := range keys {
				comma := ","
				if i == len(keys)-1 {
					comma = ""
				}
				// Escape JSON string
				escaped := strings.ReplaceAll(value, "\\", "\\\\")
				escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
				escaped = strings.ReplaceAll(escaped, "\n", "\\n")
				escaped = strings.ReplaceAll(escaped, "\r", "\\r")
				fmt.Printf("  %q: %q%s\n", name, escaped, comma)
				i++
			}
			fmt.Println("}")

		case "env":
			for name, value := range keys {
				escaped := core.EscapeDotenvValue(value)
				fmt.Printf("%s=\"%s\"\n", name, escaped)
			}

		default: // shell
			for name, value := range keys {
				// Shell escape: single quotes with escaped single quotes
				escaped := strings.ReplaceAll(value, "'", "'\"'\"'")
				fmt.Printf("export %s='%s'\n", name, escaped)
			}
		}

		return nil
	},
}

func init() {
	// inject flags
	injectCmd.Flags().StringP("provider", "p", "", "按提供商过滤")
	injectCmd.Flags().StringP("keys", "k", "", "指定密钥名称（逗号分隔）")
	injectCmd.Flags().StringP("output", "o", "", "输出文件路径（默认 .env）")
	injectCmd.Flags().BoolP("force", "f", false, "强制覆盖已存在的文件")
	injectCmd.Flags().Bool("project", false, "根据当前目录的 akm.yaml 精确注入")
	injectCmd.Flags().String("all", "", "扫描指定目录下所有含 akm.yaml 的子目录并批量注入")

	// run flags
	runCmd.Flags().StringP("provider", "p", "", "按提供商过滤")
	runCmd.Flags().StringP("keys", "k", "", "指定密钥名称（逗号分隔）")

	// export flags
	exportCmd.Flags().StringP("provider", "p", "", "按提供商过滤")
	exportCmd.Flags().StringP("keys", "k", "", "指定密钥名称（逗号分隔）")
	exportCmd.Flags().StringP("format", "F", "shell", "输出格式: shell, env, json")
}
